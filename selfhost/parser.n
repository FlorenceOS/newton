const std = @import("std");

const builder = @import("builder.n");
const error = @import("error.n");

const ExpressionType = enum(u8) {
    // simple token expressions
    identifier,
    int_literal,
    string_literal,

    // if there is no token (-1), it is a file top-level struct
    // otherwise, token is the struct/enum/union token
    // payload 0: first statement in body
    container_expression,

    // expr_idx - 1 is operand
    // uops
    addr_of,
    deref,
    unary_plus,
    unary_minus,
    unary_bitnot,
    unary_lognot,
    pointer_type,
    force_comptime_eval,

    // payload 0: lhs
    // expr_idx - 1: rhs
    // binary operators
    multiply,
    divide,
    modulus,
    add,
    subtract,
    append,

    // payload 0: first argument, other arguments are siblings
    // expr_idx - 1: callee
    // token is opening paren
    function_call,

    // payload 0: first argument decl
    // payload 1: first statement in block body
    // expr_idx - 1: return type
    // token: end paren token (before attribute list)
    function_expression,

    // expr_idx - 1: expression accessed
    // token: identifier accessed
    member_access,
};

const StatementType = enum(u8) {
    // token is var/const/fn token
    // token + 1 is identifier token
    // payload 0: type expression (optional)
    // payload 1: init expression
    static_declaration,

    // token is identifier
    // payload 0: type expression
    // payload 1: init expression (optional)
    field_declaration,

    // token is identifer (optional)
    // before token are any attribute keywords
    // payload 0: type expression
    function_parameter_decl,

    // payload 0: first child statement
    block,

    // payload 0: expression
    expression,

    // token is var/const/fn token
    // token + 1 is identifier token
    // payload 0: type expression (optional)
    // payload 1: init expression
    local_var_decl,
};

const MAX_NODES = 0x100000;

// AST Expressions
var expr_type: std.containers.PinnedVector(ExpressionType, MAX_NODES) = undefined;
var expr_token: std.containers.PinnedVector(u32, MAX_NODES) = undefined;
var expr_payload: [1]std.containers.PinnedVector(u32, MAX_NODES) = undefined;
var expr_next_sibling: std.containers.PinnedVector(u32, MAX_NODES) = undefined;

// AST Statements
var stmt_type: std.containers.PinnedVector(StatementType, MAX_NODES) = undefined;
var stmt_token: std.containers.PinnedVector(u32, MAX_NODES) = undefined;
var stmt_payload: [2]std.containers.PinnedVector(u32, MAX_NODES) = undefined;
var stmt_next_sibling: std.containers.PinnedVector(u32, MAX_NODES) = undefined;

fn init() inline void {
    expr_type.init();
    expr_token.init();
    expr_payload[0].init();
    expr_next_sibling.init();

    stmt_type.init();
    stmt_token.init();
    stmt_payload[0].init();
    stmt_payload[1].init();
    stmt_next_sibling.init();
}

fn add_expr_with_token(tok: u32, tag: ExpressionType) u32 {
    const retval = expr_type.size();
    expr_type.append_assume_capacity(tag);
    expr_token.append_assume_capacity(tok);
    _ = expr_payload[0].add();
    _ = expr_next_sibling.add();
    return retval;
}

fn add_stmt_with_token(tok: u32, tag: StatementType) u32 {
    const retval = stmt_type.size();
    stmt_type.append_assume_capacity(tag);
    stmt_token.append_assume_capacity(tok);
    _ = stmt_payload[0].add();
    _ = stmt_payload[1].add();
    _ = stmt_next_sibling.add();
    return retval;
}

const ParserContext = struct {
    current_token: u32,
    end_token: u32,

    fn advance(self: *@This()) inline void {
        self.current_token += 1;
    }

    fn remember_advance(self: *@This()) inline u32 {
        const retval = self.current_token;
        self.current_token = retval + 1;
        return retval;
    }

    fn add_expr_advance(self: *@This(), tag: ExpressionType) inline u32 {
        self.advance();
        return add_expr_with_token(self.current_token - 1, tag);
    }

    fn add_stmt_advance(self: *@This(), tag: StatementType) inline u32 {
        self.advance();
        return add_stmt_with_token(self.current_token - 1, tag);
    }

    fn peek(self: *@This()) inline tokenizer.TokenType {
        return tokenizer.token_type.get(self.current_token).*;
    }

    fn report_error(self: *@This(), message: *const u8) inline noreturn {
        tokenizer.report_error_at_token(self.current_token, message);
    }

    fn expect(self: *@This(), error_message: *const u8, expected: tokenizer.TokenType) u32 {
        const retval = self.current_token;
        if(self.peek() == expected) {
            self.advance();
            return retval;
        } else {
            self.report_error(error_message);
        }
    }
};

fn parse_statement(context: *ParserContext) u32 {
    const p = context.peek();
    if(p == .opening_curly) {
        const result = add_stmt_with_token(context.current_token, .block);
        stmt_payload[0].get(result).* = parse_block_statement(context);
        return result;
    }
    else if(p == .break_keyword) {
        context.report_error("TODO: Break statement".&);
    }
    // else if(p == .case_keyword) {
    //     context.report_error("TODO: Case statement".&);
    // }
    else if(p == .const_keyword || p == .var_keyword) {
        const result = context.add_stmt_advance(.local_var_decl);
        context.expect("Expected local variable name".&, .identifier);
        if(context.peek() == .colon) {
            context.advance();
            stmt_payload[0].get(result).* = parse_expression_with_precedence(context, 0);
        } else {
            stmt_payload[0].get(result).* = -1;
        }
        context.expect("Expected '=' after variable declaration".&, .assign);
        stmt_payload[1].get(result).* = parse_expression(context);
        context.expect("Expected ';' after variable initialization".&, .semicolon);
        return result;
    }
    // else if(p == .continue_keyword) {
    //     context.report_error("TODO: Continue statement".&);
    // }
    // else if(p == .endcase_keyword) {
    //     context.report_error("TODO: Endcase statement".&);
    // }
    // else if(p == .unreachable_keyword) {
    //     context.report_error("TODO: Unreachable statement".&);
    // }
    else if(p == .if_keyword) {
        context.report_error("TODO: If statement".&);
    }
    else if(p == .loop_keyword) {
        context.report_error("TODO: Loop statement".&);
    }
    else if(p == .return_keyword) {
        context.report_error("TODO: Return statement".&);
    }
    // else if(p == .switch_keyword) {
    //     context.report_error("TODO: Switch statement".&);
    // }
    else if(p == .identifier || p == .__keyword || p == .opening_paren) {
        const result = add_stmt_with_token(-1, .expression);
        stmt_payload[0].get(result).* = parse_expression(context);
        context.expect("Expected ';' after expression statement".&, .semicolon);
        return result;
    }
    else {
        context.report_error("Unknown statement".&);
    }
}

fn parse_block_statement_body(context: *ParserContext) u32 {
    var stmts = builder.Builder{};
    loop(context.peek() != .closing_curly) {
        stmts.add(parse_statement(context), stmt_next_sibling.ptr());
    }
    return stmts.head;
}

fn parse_block_statement(context: *ParserContext) u32 {
    context.expect("Expected '{' to start block statement".&, .opening_curly);
    const result = parse_block_statement_body(context);
    context.expect("Expected '}' to start block statement".&, .closing_curly);
    return result;
}

fn parse_function_expression(context: *ParserContext) u32 {
    context.expect("Expected '(' before parameter list".&, .opening_paren);
    var param_builder = builder.Builder{};
    loop(context.peek() != .closing_paren) {
        if(context.peek() == .comptime_keyword) {
            context.advance();
        }
        var ident: u32 = -1;
        if(context.peek() == .identifier) {
            ident = context.remember_advance();
            context.expect("Expected ':' after function parameter name".&, .colon);
        }
        const decl = add_stmt_with_token(ident, .function_parameter_decl);
        stmt_payload[0].get(decl).* = parse_expression(context);
        param_builder.add(decl, stmt_next_sibling.ptr());
        if(context.peek() == .comma) {
            context.advance();
        } else {
            break;
        }
    }
    const end_paren_tok = context.expect("Expected ')' after parameter list".&, .closing_paren);
    if(context.peek() == .inline_keyword) {
        context.advance();
    }
    if(context.peek() == .vertical_bar) {
        context.advance();
        context.expect("Expected return location binding name after '|'".&, .identifier);
        context.expect("Expected '|' after return location binding name".&, .vertical_bar);
    }
    _ = parse_expression_with_precedence(context, 0);
    const result = add_expr_with_token(end_paren_tok, .function_expression);
    expr_payload[0].get(result).* = param_builder.head;
    if(context.peek() == .opening_curly) {
        expr_payload[1].get(result).* = parse_block_statement(context);
    } else {
        expr_payload[1].get(result).* = -1;
    }
    return result;
}

fn parse_primary_expression(context: *ParserContext) u32 {
    const p = context.peek();

    if(p == .identifier) {
        return context.add_expr_advance(.identifier);
    }
    else if(p == .int_literal) {
        return context.add_expr_advance(.int_literal);
    }
    else if(p == .string_literal) {
        return context.add_expr_advance(.string_literal);
    }
    else if(p == .fn_keyword) {
        context.advance();
        return parse_function_expression(context);
    }
    else if(p == .plus) {
        const plus_tok = context.remember_advance();
        _ = parse_primary_expression(context);
        return add_expr_with_token(plus_tok, .unary_plus);
    }
    else if(p == .minus) {
        const minus_tok = context.remember_advance();
        _ = parse_primary_expression(context);
        return add_expr_with_token(minus_tok, .unary_minus);
    }
    else if(p == .tilde) {
        const bitnot_tok = context.remember_advance();
        _ = parse_primary_expression(context);
        return add_expr_with_token(bitnot_tok, .unary_bitnot);
    }
    else if(p == .asterisk) {
        context.report_error("TOOD: Pointer types".&);
    }
    else if(p == .comptime_keyword) {
        const comptime_tok = context.remember_advance();
        _ = parse_primary_expression(context);
        return add_expr_with_token(comptime_tok, .force_comptime_eval);
    }
    else {
        context.report_error("Expected primary expression".&);
    }
}

fn parse_primary_with_postfix(context: *ParserContext) u32 {
    var result = parse_primary_expression(context);

    loop {
        var p = context.peek();
        if(p == .dot) {
            context.advance();
            p = context.peek();
            if(p == .ampersand) {
                context.add_expr_advance(.addr_of);
            }
            else if(p == .asterisk) {
                context.add_expr_advance(.deref);
            }
            else if(p == .identifier) {
                context.add_expr_advance(.member_access);
            }
            else {
                context.report_error("Expected postfix token after '.'".&);
            }
        }
        else if(p == .opening_paren) {
            result = context.add_expr_advance(.function_call);
            var argument_builder = builder.Builder{};
            loop(context.peek() != .closing_paren) {
                argument_builder.add(parse_expression(context), expr_next_sibling.ptr());
                if(context.peek() == .comma) {
                    context.advance();
                } else {
                    break;
                }
            }
            context.expect("Expected ')' after argument list".&, .closing_paren);
            expr_payload[0].get(result).* = argument_builder.head;
        }
        else {
            return result;
        }
    }
}

fn parse_expression_with_precedence(context: *ParserContext, precedence: u32) u32 {
    var lhs = parse_primary_with_postfix(context);

    // Binary operators
    loop {
        var p = context.peek();

        var operator_precedence: u32 = undefined;
        var tag: ExpressionType = undefined;

        if(p == .asterisk) {
            tag = .multiply;
            operator_precedence = 3;
        }
        else if(p == .slash) {
            tag = .divide;
            operator_precedence = 3;
        }
        else if(p == .percent) {
            tag = .modulus;
            operator_precedence = 3;
        }
        else if(p == .plus) {
            tag = .add;
            operator_precedence = 4;
        }
        else if(p == .minus) {
            tag = .subtract;
            operator_precedence = 4;
        }
        else if(p == .plus_plus) {
            tag = .append;
            operator_precedence = 4;
        }
        // TODO: Add the rest of these
        // const op_prec: usize = switch(op) {
        //     .@"<<_ch", .@">>_ch" => 5,
        //     .@"&_ch", .@"^_ch", .@"|_ch" => 6,
        //     .@"==_ch", .@"!=_ch", .@"<_ch", .@"<=_ch", .@">_ch", .@">=_ch" => 7,
        //     .@"&&_ch", .@"||_ch" => 8,
        //     .@".._ch" => 9,

        //     .@"=_ch", .@"++=_ch",
        //     .@"+=_ch", .@"-=_ch", .@"*=_ch",
        //     .@"/=_ch", .@"%=_ch",
        //     .@"|=_ch", .@"&=_ch", .@"^=_ch",
        //     .@"<<=_ch", .@">>=_ch",
        //     => 10,
        // };
        else {
            return lhs;
        }

        if(operator_precedence > precedence) {
            return lhs;
        }
        if(operator_precedence == precedence && operator_precedence != 10) {
            return lhs;
        }

        const operand_token = context.remember_advance();
        const old_lhs = lhs;
        _ = old_lhs.&; // Hack to put old_lhs on stack, we're out of registers
        _ = parse_expression_with_precedence(context, operator_precedence);
        lhs = add_expr_with_token(operand_token, tag);
        expr_payload[0].get(lhs).* = old_lhs;
    }
}

fn parse_expression(context: *ParserContext) inline u32 {
    return parse_expression_with_precedence(context, 99);
}

fn parse_container_body(context: *ParserContext) u32 {
    var decl_builder = builder.Builder{};

    loop {
        const p = context.peek();

        if(p == .identifier) {
            context.report_error("TODO: Container field".&);
        }
        else if(p == .const_keyword || p == .var_keyword) {
            const decl = context.add_stmt_advance(.static_declaration);
            context.expect("Expected identifier for static declaration".&, .identifier);
            if(context.peek() == .colon) {
                context.advance();
                stmt_payload[0].get(decl).* = parse_expression_with_precedence(context, 0);
            } else {
                stmt_payload[0].get(decl).* = -1;
            }
            context.expect("Expected '=' in static decl".&, .assign);
            stmt_payload[1].get(decl).* = parse_expression(context);
            context.expect("Expected ';' after static decl".&, .semicolon);
            decl_builder.add(decl, stmt_next_sibling.ptr());
        }
        else if(p == .fn_keyword) {
            const decl = context.add_stmt_advance(.static_declaration);
            context.expect("Expected identifier for fn decl".&, .identifier);
            stmt_payload[0].get(decl).* = -1;
            stmt_payload[1].get(decl).* = parse_function_expression(context);
            decl_builder.add(decl, stmt_next_sibling.ptr());
        }
        else if(p == .closing_curly) {
            return decl_builder.head;
        }
        else {
            context.report_error("Unexpected token in container body".&);
        }
    }
}

fn parse_file(file: u32) u32 {
    var context: ParserContext = undefined;
    context.current_token = tokenizer.token_type.size();
    tokenizer.tokenize_file(file);
    context.end_token = tokenizer.token_type.size();
    const toplevel = add_expr_with_token(-1, .container_expression);
    source_files.source_files.get(file).top_level_struct = toplevel;
    const first_decl = parse_container_body(context.&);
    expr_payload[0].get(toplevel).* = first_decl;
    return toplevel;
}
